# 상속(Inheritance)과 다형성(Polymorphism)
## 상속
- 상속이란, 부모클래스의 속성과 기능을 자식클래스에게 그대로 물려주는 것
- 클래스의 멤버변수나 메소드의 추가가 필요할 경우
  1. 클래스를 직접 수정하는 방법 = 연결되어있는 코드를 모두 수정해야 할 가능성이 매우 높음
  2. 기존의 클래스를 상속받아 필요한 변수나 기능만 추가하는 방법 = 연결되어있던 기존의 코드에 영향을 주지 않고 수정 가능
### 상속의 유연성
- 상속은 기존의 클래스에서 확장한 것으로 부모 클래스를 수정할 경우 자식 클래스에서 수정된 내용을 즉시 사용할 수 있음
- 만약, 상속을 하지 않고 일일이 기능을 추가할 경우, 필요한 클래스를 모두 찾아 수정을 해야하는 불편함이 생김
- 이처럼 상속은 클래스 속성이나 기능의 추가/수정/삭제를 유연하게 처리할 수 있게 해줌
### 상속이 불가능한 final class
- 클래스 선언부에 final을 붙일경우 상속이 불가능합니다.
### 상속을 제한하는 sealed class
- Java 17부터 추가된 sealed 키워드는 final과 마찬가지로 상속을 할 수 없도록 제한하는 키워드입니다.
### 다형성(Polymorphism)
- 객체지향 프로그래밍의 4가지 특징
  1. 캡슐화
     - 여러 기능을 메소드(캡슐)로 묶어 처리
  2. 추상화
     - 기능의 정의만 존재하고 구현은 하지 않는다
  3. 다형성
     - 상속 및 구현 대상(부모클래스)타입에 포함되는 것을 허가한다
     - 즉, 하나의 타입으로 여러가지 타입을 표현할 수 있다
     - 부모가 같아도 관계가 없으면 사용 불가
  4. 상속
     - 부모클래스의 모든 속성, 기능을 확장한다
### is a 관계를 이용한 다형성
sup class is a super class

### 메소드 오버라이딩
- 부모클래스의 메소드를 자식클래스에서 재 정의
  1. 객체 지향 설계 5원칙 중 리스코프 치환의 원칙(LSP)은 is a 관계는 유지하되, 부모클래스의 메소드를 오버라이딩 하지 말 것을 권고
  2. 즉, 자식클래스에서 부모클래스의 메소드를 아무렇게나 오버라이딩 하지 말 것
- @Override 를 작성하지 않아도 메소드 오버라이딩은 정상 작동
- 단, @Override를 작성하지 않을 경우 미미한 성능하락을 일으킴
### 오버라이딩이 불가능한 final method
자식클래스가 부모클래스의 메소드를 재정의 하지 못하도록 부모클래스의 메소드에 final을 붙임
